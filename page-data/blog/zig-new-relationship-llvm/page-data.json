{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/zig-new-relationship-llvm/","webpackCompilationHash":"96fa962e26c965f95f07","result":{"data":{"site":{"siteMetadata":{"title":"Loris Cro's Personal Blog","author":"Loris Cro"}},"markdownRemark":{"id":"ce8717a1-cf25-5fe4-8131-ee06533e5379","excerpt":"In the early days, Zig was but a thin frontend in front of LLVM. This was instrumental for getting started quickly and filling in gaps of Andrew’s knowledge as…","html":"<p>In the early days, Zig was but a thin frontend in front of LLVM. This was instrumental for getting started quickly and filling in gaps of Andrew’s knowledge as a compiler developer. Now, the training wheels of the bicycle are coming off, and LLVM is transitioning into an optional component.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 400px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2cc08c37498f0cec888734c477d5f358/98017/protty1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.24263038548753%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACGElEQVQ4y5VUu2piURRV8Af8AUF/IL8gtnZWClokIAQbsVQLCxGsLBW7pIwWCYoGja/4BBFBBA2JaKEoUQvRKCY+1szewwlmEmVmweZe9tlnnbUf50jwG/v9/pvtdjsIzOdz9onYY3vIJMcWCYPBAPl8HuVyGblcDi8vLyfJfiQUyprNJjKZDEqlEuLxOJLJJGKxGLrdLq9T3D8REt7e3lgRKSMjP6m9vb3Fw8PD/xPOZjNONZ1Oo9PpoN/vs79YLCIUCvH/ZrM5TUgnkm23W96QzWZRKBRwc3PDysjvcDhwfn6OQ5Bf7GVCoeon+P1+2O12WCwWqNVqmM1mSKVSri11/uPj49seiahZu93mlCiYlEUiEahUKiZLJBJ4fX3lOspkMl6rVCpIpVIcL7KZTCZ/CEejERqNBsbjMabTKadxdXUFuVwOt9uNVqvFtbu8vGTFh1itVqx2OBzyoUdTvri4gMFgYBK9Xo9wOAylUgmn04mnpyeOeXx8RK/X+5qy6M56vcbz8zNqtRqfSt9AIIDr62vYbDZEo1FUq1UEg0GeTVKjUCg43cOuS0RXqS5nZ2ewWq1wuVx8+vv7OxMtl0vU63V4PB4eI8JisfhU+mVsRMpUB0pRq9XCaDTCZDJ9zhzh/v4eOp0Od3d3J++0REw9gZR4vV4m1mg08Pl87P9pPMTs/k0sEQGHrwt1nWooiA5v0amHgewX/+ot8NIpQjQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/2cc08c37498f0cec888734c477d5f358/f5e3c/protty1.webp 100w,\n/static/2cc08c37498f0cec888734c477d5f358/f2fbe/protty1.webp 200w,\n/static/2cc08c37498f0cec888734c477d5f358/e227a/protty1.webp 400w,\n/static/2cc08c37498f0cec888734c477d5f358/efddf/protty1.webp 441w\"\n          sizes=\"(max-width: 400px) 100vw, 400px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/2cc08c37498f0cec888734c477d5f358/c0399/protty1.png 100w,\n/static/2cc08c37498f0cec888734c477d5f358/9ec3c/protty1.png 200w,\n/static/2cc08c37498f0cec888734c477d5f358/c7805/protty1.png 400w,\n/static/2cc08c37498f0cec888734c477d5f358/98017/protty1.png 441w\"\n          sizes=\"(max-width: 400px) 100vw, 400px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/2cc08c37498f0cec888734c477d5f358/c7805/protty1.png\"\n          alt=\"protty1\"\n          title=\"protty1\"\n        />\n      </picture>\n  </a>\n    </span></p>\n<p>The work to replace the current C++ compiler implementation with a new pure Zig version has begun. Moving to a self-hosted implementation is usually considered a step towards maturity, with most benefits being felt by developers of the language itself. As an example, <a href=\"https://www.youtube.com/watch?v=cF1zJYkBW4A\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go lost</a> some speed of compilation by switching to the self-hosted compiler but, in exchange, it streamlined the toolchain, removed dependencies, and improved the whole development experience.</p>\n<p>The move to a self-hosted compiler for Zig has similar advantages for the core contributors, but it also <strong>makes LLVM an optional dependency</strong>, <strong>increases compilation speed</strong> (instead of losing it), and adds an amazing feature for debug builds of your code: <strong>incremental compilation with in-place binary patching</strong>, <a href=\"/blog/what-is-zig-comptime/\">another</a> <a href=\"/blog/zig-colorblind-async-await/\">unique</a> Zig feature.</p>\n<h2 id=\"speeding-up-compilation\"><a href=\"#speeding-up-compilation\" aria-label=\"speeding up compilation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Speeding up compilation</h2>\n<p>Most languages offer some form of caching to speed up compilation, starting from C’s compilation units, up to modules, packages, and other comparable boundaries in more modern languages.</p>\n<p>Zig also implements a caching system that comes particularly handy when building a project that mixes C and Zig source code, or when using Zig as a C compiler with the <code>zig cc</code> command. Zig keeps track of all the files involved in the compilation, so it can very easily know when an object file can be reused, and this is <a href=\"https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">only one of the advantages</a> of using Zig to compile C code.</p>\n<p>Zig sources always get bundled into a single compilation unit, so the caching system in its current form doesn’t provide any speedup when editing and recompiling a pure Zig project. The upside is that, not only compiling Zig code is very fast, but also that incremental compilation will provide smart caching for Zig code, more than making up for what we can’t get from simple caching.</p>\n<h2 id=\"incremental-compilation\"><a href=\"#incremental-compilation\" aria-label=\"incremental compilation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Incremental compilation</h2>\n<p>Incremental compilation is a form of caching that acts at a higher granularity level than normal “compilation unit”-level caching. The Rust blog has a <a href=\"https://blog.rust-lang.org/2016/09/08/incremental.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">great post</a> that explains how it works.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 400px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c8f09130b97cf9ec0fd60c85eb21418e/d4d70/rust.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.655601659751035%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABqUlEQVQozz1SyZKbUAzk//8gl+SSym1OySF3T1KZCS5wYk+5bGPA2GD23YBZOi0mM69KhST0+rXUUsBTVRVut5u46PsenufheDzicDjAdd0533Ud8jyfrWvbOTcOwxzf7/c5nqYJijhJlqGs69eicUTbNrAsC+fzeQaSIznTtuFer8gIImdg7Ym5jPffAaflE5Lv37Df7ZGGIfoRvHiC5Vxg2Q5sWnMf0PBHbBxwf/gC5CkmdkIEvJ3pv69E5hH6YoHnxSO8g4EmjKH9/IWVqkLTVli97FBkFcprgM1vFbvnJ7RFgTGKMPg+uq8P6B37FZSMFZ+stL9raH/W8KMUQz/gRdOwlss/HhF9+oDpSGZxDGupIvr8kTOKZQYyWAIHmJrbO1MlTVNcLhe4tIKzkXlcgwABAUIKkht75EmChOadTkh22znOyLKkmHXboaKgBWOZtyKKbrdb6LqOmCA+26jKEjZFsQkw8NWAXTiOA3W5hL7ZoCaAT3GahkKZ5rwJAxUPSEQxDGNWVFZEVkUAhbUwSvhARj8koMRSa7JGupCcfN9q5VtzU/4B/j1XlErag3EAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/c8f09130b97cf9ec0fd60c85eb21418e/f5e3c/rust.webp 100w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/f2fbe/rust.webp 200w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/e227a/rust.webp 400w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/965c5/rust.webp 600w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/0cbce/rust.webp 800w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/16e88/rust.webp 964w\"\n          sizes=\"(max-width: 400px) 100vw, 400px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/c8f09130b97cf9ec0fd60c85eb21418e/c0399/rust.png 100w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/9ec3c/rust.png 200w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/c7805/rust.png 400w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/34e8a/rust.png 600w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/8ff1e/rust.png 800w,\n/static/c8f09130b97cf9ec0fd60c85eb21418e/d4d70/rust.png 964w\"\n          sizes=\"(max-width: 400px) 100vw, 400px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/c8f09130b97cf9ec0fd60c85eb21418e/c7805/rust.png\"\n          alt=\"rust\"\n          title=\"Taken from the Rust blog post linked above.\"\n        />\n      </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Taken from the Rust blog post linked above.</figcaption>\n  </figure></p>\n<p>In the case of Rust, the compiler builds a dependency graph at the AST level and then saves it to disk alongside the cached intermediate results (object files). When a new compilation is requested, the compiler will be able to easily notice which parts of the AST have changed and thus invalidate all the intermediate results that depend on it.</p>\n<p>One important detail about this graph is the fact that the right-most box is always invalidated. In other words, the final executable is always re-linked from scratch starting from a mix of old and newly generated object files. It’s clear that this has to be the case, since the final executable depends on everything else and so any meaningful change to the code will invalidate it, but this is where the Zig self-hosted compiler brings a new ingenious idea to the table.</p>\n<h2 id=\"in-place-binary-patching\"><a href=\"#in-place-binary-patching\" aria-label=\"in place binary patching permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>In-Place Binary Patching</h2>\n<p>As of Zig version 0.6.0, regardless of the type of release (debug, release-safe, release-fast), there is always a final step delegated to <strong>LLVM, which takes at least 70% of the total compilation time</strong> including when compiling a debug build, where optimizations aren’t even enabled.</p>\n<p><strong>The self-hosted compiler will not depend on LLVM for debug builds</strong> and will be able to cut compilation time considerably, <strong>basically reducing that 70% to almost zero</strong>, just by virtue of being a simpler piece of software compared to LLVM. </p>\n<p>On top of that, since the compiler will have full control over the whole process, it will generate machine code using an ad-hoc strategy optimized for incremental compilation, allowing the compiler to patch the final executable in-place with the new changes. </p>\n<p>In-place binary patching is based on a granularity of top-level declarations. Each global variable and function can be independently patched because the final binary is structured as a sequence of loosely coupled blocks. Another important characteristic is that all this information is kept in memory, so the compiler will stay open between compilations.</p>\n<p> If you want to see the self-hosted compiler in action, here’s a 5 minute demo by Andrew:</p>\n\n          <div\n            class=\"gatsby-resp-iframe-wrapper\"\n            style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden;margin-bottom: 1.0725rem\"\n          >\n            <iframe src=\"https://www.youtube-nocookie.com/embed/R5FKgi9BYyU\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen style=\"\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n          \"></iframe>\n          </div>\n          \n<h2 id=\"designing-machine-code-for-incremental-compilation\"><a href=\"#designing-machine-code-for-incremental-compilation\" aria-label=\"designing machine code for incremental compilation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Designing machine code for incremental compilation</h2>\n<p>Efficient in-place binary patching is something that can only be accomplished by tightly coupling the compiler frontend and backend. Part of the reason this feature is so rarely seen in the wild is that it goes against our better sense of abstraction and clean code organization. But we must never forget: abstraction is just a tool to reach a practical outcome, and not always the most appropriate one.</p>\n<p>In order to perform in-place binary patching, we need code to be <a href=\"https://en.wikipedia.org/wiki/Position-independent_code\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">position independent</a>. This allows us to move it around in virtual memory when a function grows outside its allocated boundary. We also need to be able to reference virtual addresses indirectly, so that N callsites do not need to be updated when a function is moved to a new virtual address.</p>\n<p>To accomplish this Zig uses a Global Offset Table for all function calls.</p>\n<p>However, that only solves functions. There are more components to consider here, such as debug information. When we add new lines to a function, that modifies the debug information, which is used to print stack traces! Solving this involves creatively organizing an allocation scheme for debug line information, and figuring out how to do NOPs. Andrew’s journey here involved creating a <a href=\"http://dwarfstd.org/ShowIssue.php?issue=200803.1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">proposal for a new DWARF line number opcode</a>.</p>\n<p>This problem must be solved repeatedly for each kind of linking backend - ELF, DWARF, PE, PDB, MachO, and WebAssembly. Special thanks for the contributors who have stepped up and taken on the added challenge of supporting in-place binary patching: <a href=\"https://github.com/alexnask\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Alexandros Naskos</a>, <a href=\"http://www.jakubkonka.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Jakub Konka</a>, and <a href=\"https://ifreund.xyz/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Isaac Freund</a>.</p>\n<p>Be on the lookout for a more technical post on <a href=\"https://andrewkelley.me\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Andrew’s blog</a>, where he’ll dive into some of these fascinating details — <strong>including how this design gets us 90% of the way to hot code swapping!</strong></p>\n<h2 id=\"when-is-it-going-to-be-ready\"><a href=\"#when-is-it-going-to-be-ready\" aria-label=\"when is it going to be ready permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>When is it going to be ready?</h2>\n<p>The self-hosted backend is <a href=\"https://github.com/ziglang/zig/projects/2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">still a work in progress</a>, but all the functionalities presented in this post have been designed and prototyped to the point where it’s just a matter of doing the methodical part of the work.</p>\n<p>The self-hosted backend will ship in Zig 0.7.0 behind a flag, supporting only a subset of the Zig language. In the meantime, the core development team and a few other contributors are sprinting forward with more language support and additional targets. The current aim is to fully replace the C++ implementation with the self-hosted backend for Zig 0.8.0, roughly 7 months from now.</p>\n<p>If you like where Zig is going, there’s no better time <a href=\"https://github.com/ziglang/zig/wiki/Community\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">to join the Zig community</a> than now, and if you want to help speed the development up, please <a href=\"https://ziglang.org/zsf/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">consider donating to the Zig Software Foundation</a> to allow core developers to spend more time working on Zig.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 400px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/8eeed/protty2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 107.37100737100738%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAACt0lEQVQ4y41US0tyURT1R/Qf/AMOnASOGkRCQQlig6ASKmwkOjIJHDYpqLBmkRhEYRgkmIhiD8xHFOEDirJSMZWoQCtrfewN53K9mV8bDuee1zpr7bXPVX1/f0O0r68vUNTrdWxubiKXy/H48/MTImif6JWNQiXfIOLy8hLr6+vY3t5GtVqVQAVwJ7A2QDFoNpv4+PjA29sbEokEHh8fcXh4iEgkwuB+v/9vgBSNRgNLS0s4OjrC/v4+pqamYLPZGJCk7+7uYm9vj/dSav4L2Gq1GIgOWywWuFwumM1meDweBkomk13ZdZRMMonVwsICHh4eUCwWYbVaEQgE2sC6miKczWQy2NjYYEModnZ2GJzY3t/fSyoox10lC8CzszNmcnV1hff3d7jdbvh8Ptze3iKVSkEZnRxnQLqV4vT0FNlsFicnJ4hGo9zPz89jeXkZNzc3vIeYUl7L5XKbOfKyk0x5fX1lR8/Pz7lNTk5idHQU/f39LJ1SQoap1WqMj48jn89DkPnVFJJBt6+urmJ4eJjdNRgM6OnpweLiIsbGxnhta2uLL1OW0I+XIm4kQ+gw1eXAwAC0Wi0rqFQqWFtbQ6lUkmR3lKx8y7VaDRMTE5iZmYFOp8Pc3ByvHRwccMH39fXxQ/iVoXxCsHx5eWGmVOwUz8/P0Ov1LNXpdEpGiXMCWCWYCXadgt52oVDA0NAQRkZGcHFxwfNUk0RA/mNRyQf0/fT0xAeOj4/Z9WAwyGO73Q6NRoPe3l4GDoVCXF7hcBixWAzpdJpVqQiIkh2Px3mR6vH6+ppNEEEsSOrKygqmp6dhNBqlHAqmVKOkhAGJ1d3d3Q+pcudnZ2dhMpkwODgIh8MhlZlcYdvTEwAin/JkU9BzpJLxer1t++UVwqbIgZS3dfqbK9eUcyoB1K0XeSSJlK9u+/4BCgDpKvxRAzUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/f5e3c/protty2.webp 100w,\n/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/f2fbe/protty2.webp 200w,\n/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/e227a/protty2.webp 400w,\n/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/44d87/protty2.webp 407w\"\n          sizes=\"(max-width: 400px) 100vw, 400px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/c0399/protty2.png 100w,\n/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/9ec3c/protty2.png 200w,\n/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/c7805/protty2.png 400w,\n/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/8eeed/protty2.png 407w\"\n          sizes=\"(max-width: 400px) 100vw, 400px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/2ec6c0ef555e8f1383c4cb5d7b3edba2/c7805/protty2.png\"\n          alt=\"protty2\"\n          title=\"Thanks to kprotty for the cute doodles!\"\n        />\n      </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Thanks to kprotty for the cute doodles!</figcaption>\n  </figure></p>","frontmatter":{"title":"Zig's New Relationship with LLVM","date":"September 28, 2020","description":"While not yet at version 1.0, Zig is about to reach a new level of maturity and stability.","notwitch":true,"coauthor_link":"https://andrewkelley.me","coauthor":"Andrew Kelley"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/zig-new-relationship-llvm/","readingTime":{"text":"7 min read"},"previous":{"fields":{"slug":"/blog/addio-redis/","readingTime":{"text":"6 min read"}},"frontmatter":{"title":"Addio Redis, I'm leaving Redis Labs"}},"next":{"fields":{"slug":"/blog/you-should-play-secret-hitler/","readingTime":{"text":"9 min read"}},"frontmatter":{"title":"You Sould Play Secret Hitler"}}}}}