<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&family=Montserrat:wght@700;900&display=swap" rel=stylesheet><link type=text/css rel=stylesheet href=http://kristoff.it/main.min.503dbda161a63bd493119c08c60ba20ee47c80b4fa62d5ab83f21dac48ae6523.css><script async src=https://platform.twitter.com/widgets.js></script>
<script defer type=text/javascript src=https://api.pirsch.io/pirsch.js id=pirschjs data-code=CnorXJVVDmhCee3FBtXSQISdHIUmqp3o></script><meta name=description content="Let&rsquo;s take a quick look at what compile-time execution looks like in Zig."><meta name=twitter:card content="summary"><meta name=twitter:site content="@croloris"><meta name=twitter:image content="https://kristoff.it/logo.png"><meta name=twitter:author content="@croloris"><meta name=twitter:description content="Let&rsquo;s take a quick look at what compile-time execution looks like in Zig."><meta name=twitter:title content="What is Zig's Comptime?"><meta property="og:title" content="What is Zig's Comptime?"><meta property="og:type" content="website"><meta property="og:image" content="https://krisoff.it/logo.png"><link type=text/css rel=stylesheet href=http://kristoff.it/term-highlight.min.72dc284af3ddc852ffaaf0b1722b02a3d7bef69b924c63162a3addbf2b11a6d3.css></head><body><div id=content><center><h1 id=header><a class=reset-a href=/>Loris Cro</a></h1><small><i>Personal Website</i></small><div style=display:flex;justify-content:center;font-size:small><a href=/>About</a>
&nbsp; • &nbsp;
<a href=https://twitter.com/croloris>Twitter</a>
&nbsp; • &nbsp;
<a href=https://twitch.tv/kristoff_it>Twitch</a>
&nbsp; • &nbsp;
<a href=https://youtube.com/channel/ZigSHOWTIME/>YouTube</a>
&nbsp; • &nbsp;
<a href=https://github.com/kristoff-it>GitHub</a></div></center><h1>What is Zig's Comptime?</h1><p class=post-byline>August 05, 2019 • 9 min read • by <b>Loris Cro</b></p><div id=post-description>Let's take a quick look at what compile-time execution looks like in Zig.</div><div id=post-body><p>If you&rsquo;ve only experienced compile-time execution in the form of macros, generics or codegen, be ready to be surprised by what Zig can do.</p><h2 id=what-is-zig>What is Zig</h2><p>Zig is a new general-purpose programming language developed by Andrew Kelley. While still under heavy development, I think the language is already showing great promise. Zig aims to be a better C, similarly to how Rust can be understood as a better C++, generally speaking. Zig has no garbage collection, no built-in event loops, nor other runtime machinery of that level. It&rsquo;s lean just like C, and in fact it can interoperate with C pretty easily. For a complete overview checkout <a href=https://ziglang.org>https://ziglang.org</a>.</p><p>Now that you got a general idea about the level of abstraction in which Zig operates, you won&rsquo;t be surprised to know that there is absolutely no support for reflection at runtime; but what you can&rsquo;t do a runtime, you can certainly do at compile-time.</p><h2 id=running-code-at-compile-time>Running code at compile-time</h2><p>Let&rsquo;s start with the basics: using the <code>comptime</code> keyword to run arbitrary code at compilation-time.</p><h4 id=compile-time-function-calls>Compile-time function calls</h4><p>The following code uses a function to decide the length of a statically-allocated array.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>fn</span> multiply(a<span style=color:#f92672>:</span> <span style=color:#66d9ef>i64</span>, b<span style=color:#f92672>:</span> <span style=color:#66d9ef>i64</span>) <span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>*</span> b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> main() <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>const</span> len <span style=color:#f92672>=</span> <span style=color:#66d9ef>comptime</span> multiply(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> my_static_array<span style=color:#f92672>:</span> [len]<span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>undefined</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note how the function definition doesn&rsquo;t have any attribute that states it must be available at compile-time. It&rsquo;s just a normal function, and we request its compile-time execution at the call site.</p><h4 id=compile-time-blocks>Compile-time blocks</h4><p>You can also use <code>comptime</code> to define a compile-time block inside a function. The following example is a case-insensitive string compare function that is optimized for the use-case where one of the two strings is hardcoded. Compile-time execution ensures that the function doesn&rsquo;t get misused.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#75715e>// Compares two strings ignoring case (ascii strings only).
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Specialzied version where `uppr` is comptime known and *uppercase*.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> insensitive_eql(<span style=color:#66d9ef>comptime</span> uppr<span style=color:#f92672>:</span> []<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span>, str<span style=color:#f92672>:</span> []<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>comptime</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>        <span style=color:#66d9ef>var</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex;background-color:#3c3d38><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> uppr.len) <span style=color:#f92672>:</span> (i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex;background-color:#3c3d38><span>            <span style=color:#66d9ef>if</span> (uppr[i] <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>and</span> uppr[i] <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;z&#39;</span>) {
</span></span><span style=display:flex;background-color:#3c3d38><span>                @compileError(<span style=color:#e6db74>&#34;`uppr` must be all uppercase&#34;</span>);
</span></span><span style=display:flex;background-color:#3c3d38><span>            }
</span></span><span style=display:flex;background-color:#3c3d38><span>        }
</span></span><span style=display:flex;background-color:#3c3d38><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> uppr.len) <span style=color:#f92672>:</span> (i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> val <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> (str[i] <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>and</span> str[i] <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;z&#39;</span>)
</span></span><span style=display:flex><span>            str[i] <span style=color:#f92672>-</span> <span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            str[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (val <span style=color:#f92672>!=</span> uppr[i]) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> main() <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> x <span style=color:#f92672>=</span> insensitive_eql(<span style=color:#e6db74>&#34;Hello&#34;</span>, <span style=color:#e6db74>&#34;hElLo&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Compilation of this program fails and produces the following output.</p><pre class="dark-default-dark vscode-highlight" data-language=shell>
<code class="vscode-highlight-code vscode-highlight-line"><span class=bold><span class=f2>➜</span></span> zig build-exe ieq.zig                                       
<span class=bold>/Users/loriscro/ieq.zig:8:17: <span class=f1><span class=bold>error:</span></span> `uppr` must be all uppercase</span>
                @compileError(&quot;`uppr` must be all uppercase&quot;);
                <span class=f2><span class=bold>^</span></span>
<span class=bold>/Users/loriscro/ieq.zig:24:30: <span class=f6><span class=bold>note:</span></span> called from here</span>
    const x = insensitive_eql(&quot;Hello&quot;, &quot;hElLo&quot;);
                             <span class=f2><span class=bold>^</span></span>
</code>
</pre><h4 id=compile-time-code-elision>Compile-time code elision</h4><p>Zig can statically resolve control flow expressions that depend on compile-time known values. For example, you can force loop unrolling on <code>while</code> / <code>for</code> loops and elide branches from <code>if</code> / <code>switch</code> statements. The following program asks the user for a number and then iteratively applies a list of operations to it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>const</span> builtin <span style=color:#f92672>=</span> @import(<span style=color:#e6db74>&#34;builtin&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> std <span style=color:#f92672>=</span> @import(<span style=color:#e6db74>&#34;std&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> fmt <span style=color:#f92672>=</span> std.fmt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> io <span style=color:#f92672>=</span> std.io;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> Op <span style=color:#f92672>=</span> <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>    Sum,
</span></span><span style=display:flex><span>    Mul,
</span></span><span style=display:flex><span>    Sub,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> ask_user() <span style=color:#f92672>!</span><span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> buf<span style=color:#f92672>:</span> [<span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>undefined</span>;
</span></span><span style=display:flex><span>    std.debug.warn(<span style=color:#e6db74>&#34;A number please: &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> user_input <span style=color:#f92672>=</span> <span style=color:#66d9ef>try</span> io.readLineSlice(buf[<span style=color:#ae81ff>0</span>..]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fmt.parseInt(<span style=color:#66d9ef>i64</span>, user_input, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> apply_ops(<span style=color:#66d9ef>comptime</span> operations<span style=color:#f92672>:</span> []<span style=color:#66d9ef>const</span> Op, num<span style=color:#f92672>:</span> <span style=color:#66d9ef>i64</span>) <span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> acc<span style=color:#f92672>:</span> <span style=color:#66d9ef>i64</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>for</span> (operations) <span style=color:#f92672>|</span>op<span style=color:#f92672>|</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>        <span style=color:#66d9ef>switch</span> (op) {
</span></span><span style=display:flex;background-color:#3c3d38><span>            .Sum <span style=color:#f92672>=&gt;</span> acc <span style=color:#f92672>+%=</span> num,
</span></span><span style=display:flex;background-color:#3c3d38><span>            .Mul <span style=color:#f92672>=&gt;</span> acc <span style=color:#f92672>*%=</span> num,
</span></span><span style=display:flex;background-color:#3c3d38><span>            .Sub <span style=color:#f92672>=&gt;</span> acc <span style=color:#f92672>-%=</span> num,
</span></span><span style=display:flex;background-color:#3c3d38><span>        }
</span></span><span style=display:flex;background-color:#3c3d38><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> acc;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> main() <span style=color:#f92672>!</span><span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> user_num <span style=color:#f92672>=</span> <span style=color:#66d9ef>try</span> ask_user();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> ops <span style=color:#f92672>=</span> [<span style=color:#ae81ff>4</span>]Op{.Sum, .Mul, .Sub, .Sub};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> x <span style=color:#f92672>=</span> apply_ops(ops[<span style=color:#ae81ff>0</span>..], user_num);
</span></span><span style=display:flex><span>    std.debug.warn(<span style=color:#e6db74>&#34;Result: {}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The interesting part of this code is the <code>for</code> loop. The <code>inline</code> keyword forces loop unrolling, and inside the loop&rsquo;s body there is a <code>switch</code> statement that also gets resolved at compile-time. In short, the invocation of <code>apply_ops</code> in the previous example basically resolves to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>var</span> acc<span style=color:#f92672>:</span> <span style=color:#66d9ef>i64</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>acc <span style=color:#f92672>+%=</span> num;
</span></span><span style=display:flex><span>acc <span style=color:#f92672>*%=</span> num;
</span></span><span style=display:flex><span>acc <span style=color:#f92672>-%=</span> num;
</span></span><span style=display:flex><span>acc <span style=color:#f92672>-%=</span> num;
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> acc;
</span></span></code></pre></div><p>To test that this is really what&rsquo;s happening, paste the program code in <a href=https://godbolt.org>https://godbolt.org</a>, select Zig as target language, and then select a version of Zig greater than 0.4.0 (at the moment of writing you must select &ldquo;zig trunk&rdquo;). Godbolt will compile the code and show you the generated assembly. Right-click on a line of code, and a contextual menu will let you jump to the assembly code that the line corresponds to. You will notice that neither the <code>for</code> loop, nor the <code>switch</code> correspond to any assembly. Remove the <code>inline</code> keyword, and they will now show up.</p><h2 id=generics>Generics</h2><p>The <code>comptime</code> keyword indicates code regions and values that must be resolved at compile-time. In the previous examples we used it to perform something similar to template metaprogramming, but it can also be used for generic programming, since types are valid compile-time values.</p><h4 id=generic-functions>Generic functions</h4><p>Since generic programming is tied to <code>comptime</code> arguments, Zig doesn&rsquo;t have the <em>traditional</em> diamond bracket syntax. Other than that, basic usage of generics is very similar to other languages. The following code is Zig&rsquo;s implementation of <code>mem.eql</code>, taken from the standard library. It&rsquo;s used to test two slices for equality.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#75715e>/// Compares two slices and returns whether they are equal.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> eql(<span style=color:#66d9ef>comptime</span> T<span style=color:#f92672>:</span> <span style=color:#66d9ef>type</span>, a<span style=color:#f92672>:</span> []<span style=color:#66d9ef>const</span> T, b<span style=color:#f92672>:</span> []<span style=color:#66d9ef>const</span> T) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a.len <span style=color:#f92672>!=</span> b.len) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (a) <span style=color:#f92672>|</span>item, index<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (b[index] <span style=color:#f92672>!=</span> item) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, <code>T</code> is a variable of type <code>type</code> and the subsequent arguments use it as a generic parameter. This way it&rsquo;s possible to use <code>mem.eql</code> with any kind of slice.</p><p>It&rsquo;s also possible to do introspection on values of type <code>type</code>. In a previous example we parsed an integer number from user input and requested a specific type of integer. The parsing function uses that information to elide some code from its generic implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#75715e>// This is the line in `apply_ops` where we parsed a number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>return</span> fmt.parseInt(<span style=color:#66d9ef>i64</span>, user_input, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This is the stdlib implementation of `parseInt`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> parseInt(<span style=color:#66d9ef>comptime</span> T<span style=color:#f92672>:</span> <span style=color:#66d9ef>type</span>, buf<span style=color:#f92672>:</span> []<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span>, radix<span style=color:#f92672>:</span> <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>!</span>T {
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>T.is_signed) <span style=color:#66d9ef>return</span> parseUnsigned(T, buf, radix);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buf.len <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> T(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buf[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;-&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> math.negate(<span style=color:#66d9ef>try</span> parseUnsigned(T, buf[<span style=color:#ae81ff>1</span>..], radix));
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (buf[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;+&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> parseUnsigned(T, buf[<span style=color:#ae81ff>1</span>..], radix);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> parseUnsigned(T, buf, radix);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=generic-structs>Generic structs</h4><p>Before describing how to create generic structs, here&rsquo;s a brief introduction on how structs work in Zig.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>const</span> std <span style=color:#f92672>=</span> @import(<span style=color:#e6db74>&#34;std&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> math <span style=color:#f92672>=</span> std.math;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> assert <span style=color:#f92672>=</span> std.debug.assert;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// A struct definition doesn&#39;t include a name.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Assigning the struct to a variable gives it a name.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> Point <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    x<span style=color:#f92672>:</span> <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>    y<span style=color:#f92672>:</span> <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>    z<span style=color:#f92672>:</span> <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A struct definition can also contain namespaced functions.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// This has no impact on the struct layout.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Struct functions that take a Self parameter, when
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// invoked through a struct instance, will automatically
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// fill the first argument, just like methods do.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> Self <span style=color:#f92672>=</span> @This();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> distance(self<span style=color:#f92672>:</span> Self, p<span style=color:#f92672>:</span> Point) <span style=color:#66d9ef>f64</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> x2 <span style=color:#f92672>=</span> math.pow(<span style=color:#66d9ef>f64</span>, self.x <span style=color:#f92672>-</span> p.x, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> y2 <span style=color:#f92672>=</span> math.pow(<span style=color:#66d9ef>f64</span>, self.y <span style=color:#f92672>-</span> p.y, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> z2 <span style=color:#f92672>=</span> math.pow(<span style=color:#66d9ef>f64</span>, self.z <span style=color:#f92672>-</span> p.z, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> math.sqrt(x2 <span style=color:#f92672>+</span> y2 <span style=color:#f92672>+</span> z2);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> main() <span style=color:#f92672>!</span><span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> p1 <span style=color:#f92672>=</span> Point{ .x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, .y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>, .z <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> p2 <span style=color:#f92672>=</span> Point{ .x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, .y <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>, .z <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    assert(p1.distance(p2) <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    assert(Point.distance(p1, p2) <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;re now ready to talk about generic structs. To create a generic struct, all you have to do is create a function that takes a type argument and use that argument in your struct definition. Here&rsquo;s an example lifted from Zig&rsquo;s documentation. It&rsquo;s a doubly-linked intrusive list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>fn</span> LinkedList(<span style=color:#66d9ef>comptime</span> T<span style=color:#f92672>:</span> <span style=color:#66d9ef>type</span>) <span style=color:#66d9ef>type</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> Node <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>            prev<span style=color:#f92672>:</span> <span style=color:#f92672>?*</span>Node <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>            next<span style=color:#f92672>:</span> <span style=color:#f92672>?*</span>Node <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>            data<span style=color:#f92672>:</span> T,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        first<span style=color:#f92672>:</span> <span style=color:#f92672>?*</span>Node <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>        last<span style=color:#f92672>:</span> <span style=color:#f92672>?*</span>Node <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>        len<span style=color:#f92672>:</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The function returns a <code>type</code>, which means it can only be called at comptime. It defines two structs:</p><ul><li>The main <code>LinkedList</code> struct</li><li>The <code>Node</code> struct, namespaced inside the main struct</li></ul><p>Just like structs can namespace functions, they can also namespace variables. This is especially useful for introspection when creating composite types. Here&rsquo;s how <code>LinkedList</code> can be composed with our previous <code>Point</code> struct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#75715e>// To try this code, paste both definitions in the same file.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> PointList <span style=color:#f92672>=</span> LinkedList(Point);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> p <span style=color:#f92672>=</span> Point{ .x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, .y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>, .z <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> my_list <span style=color:#f92672>=</span> PointList{};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// A complete implementation would offer an `append` method.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// For now let&#39;s add the new node manually.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> node <span style=color:#f92672>=</span> PointList.Node{ .data <span style=color:#f92672>=</span> p };
</span></span><span style=display:flex><span>my_list.first <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>node;
</span></span><span style=display:flex><span>my_list.last <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>node;
</span></span><span style=display:flex><span>my_list.len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p>The Zig standard library contains <a href=https://github.com/ziglang/zig/blob/ddf7942aaa6a41296d9338423dcdfb93b915e4df/std/linked_list.zig>a couple of fleshed out implementations of linked lists</a>.</p><h2 id=compile-time-reflection>Compile-time reflection</h2><p>Now that we have covered all the basics, we can finally move onto the things that make Zig metaprogramming truly powerful and fun to use.</p><p>We already saw an example of reflection when <code>parseInt</code> was checking <code>T.is_signed</code>, but in this section I want to focus on a more advanced usage of reflection. I&rsquo;ll introduce the concept with a code sample.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>fn</span> make_couple_of(x<span style=color:#f92672>:</span> anytype) [<span style=color:#ae81ff>2</span>]@typeOf(x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>2</span>]@typeOf(x) {x, x};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This &ndash; mostly useless &ndash; function can take any value as input and creates an array that contains two copies of it. The following invocations are all correct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span>make_couple_of(<span style=color:#ae81ff>5</span>); <span style=color:#75715e>// creates [2]comptime_int{5, 5}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>make_couple_of(<span style=color:#66d9ef>i32</span>(<span style=color:#ae81ff>5</span>)); <span style=color:#75715e>// creates [2]i32{5, 5}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>make_couple_of(<span style=color:#66d9ef>u8</span>); <span style=color:#75715e>// creates [2]type{u8, u8}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>make_couple_of(<span style=color:#66d9ef>type</span>); <span style=color:#75715e>// creates [2]type{type, type}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>make_couple_of(make_couple_of(<span style=color:#e6db74>&#34;hi&#34;</span>)); 
</span></span><span style=display:flex><span><span style=color:#75715e>// creates [2][2][2]u8{[2][2]u8{&#34;hi&#34;,&#34;hi&#34;}, [2][2]u8{&#34;hi&#34;,&#34;hi&#34;}}
</span></span></span></code></pre></div><p>Arguments of type <code>anytype</code> are very powerful and allow construction of optimized and yet &ldquo;dynamic&rdquo; functions. For the next example I&rsquo;ll lift some more code from the standard library to showcase a more useful use of this functionality.</p><p>The following code is the implementation of <code>math.sqrt</code>, which we used in a previous example to compute the euclidean distance between two points.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#75715e>// I moved part of the original definition to
</span></span></span><span style=display:flex><span><span style=color:#75715e>// a separate function for better readability.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> decide_return_type(<span style=color:#66d9ef>comptime</span> T<span style=color:#f92672>:</span> <span style=color:#66d9ef>type</span>) <span style=color:#66d9ef>type</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (@typeId(T) <span style=color:#f92672>==</span> TypeId.Int) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> @IntType(<span style=color:#66d9ef>false</span>, T.bit_count <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> T;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> sqrt(x<span style=color:#f92672>:</span> anytype) decide_return_type(@typeOf(x)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> T <span style=color:#f92672>=</span> @typeOf(x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (@typeId(T)) {
</span></span><span style=display:flex><span>        TypeId.ComptimeFloat <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> T(@sqrt(<span style=color:#66d9ef>f64</span>, x)),
</span></span><span style=display:flex><span>        TypeId.Float <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> @sqrt(T, x),
</span></span><span style=display:flex><span>        TypeId.ComptimeInt <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>comptime</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&gt;</span> maxInt(<span style=color:#66d9ef>u128</span>)) {
</span></span><span style=display:flex><span>                @compileError(
</span></span><span style=display:flex><span>                	<span style=color:#e6db74>&#34;sqrt not implemented for &#34;</span> <span style=color:#f92672>++</span> 
</span></span><span style=display:flex><span>                	<span style=color:#e6db74>&#34;comptime_int greater than 128 bits&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                @compileError(<span style=color:#e6db74>&#34;sqrt on negative number&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> T(sqrt_int(<span style=color:#66d9ef>u128</span>, x));
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        TypeId.Int <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> sqrt_int(T, x),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>=&gt;</span> @compileError(<span style=color:#e6db74>&#34;not implemented for &#34;</span> <span style=color:#f92672>++</span> @typeName(T)),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The return type of this function is a bit peculiar. If you look at the signature of <code>sqrt</code>, it&rsquo;s calling a function in the place where it should be declaring the return type. This is allowed in Zig. The original code actually inlines an <code>if</code> expression, but I moved it to a separate function for better readability.</p><p>So what is <code>sqrt</code> trying to do with its return type? It&rsquo;s applying a small optimization when we&rsquo;re passing in an integer value. In that case the function declares its return type as an <strong>unsigned</strong> integer with <strong>half the bit size</strong> of the original input. This means that, if we&rsquo;re passing in an <code>i64</code> value, the function will return an <code>u32</code> value. This makes sense given what the square root function does. The rest of the declaration then uses reflection to further specialize and report compile-time errors where appropriate.</p><h2 id=in-conclusion>In conclusion</h2><p>Compile-time execution is great, especially when the language is very expressive. Without good compile-time metaprogramming, one must resort to macros or codegen, or worse, do a lot of useless work at runtime.</p><p>If you want to see one more cool example of what can be done at compile-time in Zig, <a href=https://andrewkelley.me/post/string-matching-comptime-perfect-hashing-zig.html>take a look at this blog post by Andrew himself</a>. In it, he uses some the aforementioned techniques to generate a perfect hashing function for a compile-time known list of strings. The result is that the user can create a switch that matches strings in <code>O(1)</code>. The code is very easy to understand, and he offers some insight on how all the other minor features make user abstractions easy, fun and safe to use.</p></div><hr><div id=prev-next><a href=/blog/simple-not-just-easy/>← I Want Simple, Not Just Easy</a>
&nbsp; • &nbsp;
<a href=/blog/why-go-and-not-rust/>Why Go and not Rust? →</a>
<small>&nbsp; or &nbsp;</small>
<small><a href=/>Back to the Homepage</a></small></div></div></body></html>